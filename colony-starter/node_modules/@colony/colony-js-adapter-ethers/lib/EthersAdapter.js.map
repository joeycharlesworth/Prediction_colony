{"version":3,"sources":["../src/EthersAdapter.js"],"names":["EthersAdapter","loader","provider","wallet","query","load","abi","address","bytecode","Error","EthersContract","contractParams","Contract","getDeployTransaction","transactionHash","getTransactionReceipt","receipt","timeoutMs","DEFAULT_TRANSACTION_WAIT_TIMEOUT","waitForTransaction","_getTransactionReceipt","toString","includes","messageHash","messageBytes","ethers","utils","arrayify","signMessage","signature","splitSignature","sigR","r","sigS","s","sigV","v","digest","recoveryParam","SigningKey","recover"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;AACA;;AAWA;;;;AAGA;;;;AAEA;;;;IAEqBA,a;AAOnB,+BAA2D;AAAA,QAA7CC,MAA6C,QAA7CA,MAA6C;AAAA,QAArCC,QAAqC,QAArCA,QAAqC;AAAA,QAA3BC,MAA2B,QAA3BA,MAA2B;AAAA;;AACzD,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACD;;;;;4GAEiBC,K;;;;;;;;uBAEP,KAAKH,MAAL,CAAYI,IAAZ,CAAiBD,KAAjB,EAAwB;AAC7BE,uBAAK,IADwB;AAE7BC,2BAAS,IAFoB;AAG7BC,4BAAU;AAHmB,iBAAxB,C;;;;;;;;;;8BAIA,E;;;;AALDD,uB,SAAAA,O;AAASD,mB,SAAAA,G;;sBAOb,OAAOC,OAAP,KAAmB,Q;;;;;sBACf,IAAIE,KAAJ,CAAU,kCAAV,C;;;iDAED,IAAIC,wBAAJ,CAAmBH,OAAnB,EAA4BD,GAA5B,EAAiC,KAAKH,MAAtC,C;;;;;;;;;;;;;;;;;;;6GAIPC,K,EACAO,c;;;;;;;;;;uBAEgC,KAAKV,MAAL,CAAYI,IAAZ,CAAiBD,KAAjB,EAAwB;AACtDE,uBAAK,IADiD;AAEtDC,2BAAS,KAF6C;AAGtDC,4BAAU;AAH4C,iBAAxB,C;;;;AAAxBF,mB,SAAAA,G;AAAKE,wB,SAAAA,Q;kDAKN,qCAAOI,QAAP,EAAgBC,oBAAhB,0BACLL,QADK,EAELF,GAFK,0CAGFK,cAHE,G;;;;;;;;;;;;;;;;;;;6GAOoBG,e;;;;;;;uBACL,KAAKZ,QAAL,CAAca,qBAAd,CAAoCD,eAApC,C;;;AAAhBE,uB;;sBACFA,WAAW,I;;;;;sBACP,IAAIP,KAAJ,kDAC2CK,eAD3C,O;;;kDAGDE,O;;;;;;;;;;;;;;;;;;;6GAIPF,e;YACAG,S,uEAAoBC,0C;;;;;kDAEb,uCACL,KAAKhB,QAAL,CAAciB,kBAAd,CAAiCL,eAAjC,CADK,EAELG,SAFK,C;;;;;;;;;;;;;;;;;;;6GAMmBH,e,EAAyBG,S;;;;;;AAC/CD,uB;;;uBAIc,KAAKI,sBAAL,CAA4BN,eAA5B,C;;;AAAhBE,uB;;;;;;;;oBAGK,aAAMK,QAAN,GAAiBC,QAAjB,CAA0B,+BAA1B,C;;;;;;;;oBAKFN,O;;;;;;uBACG,KAAKG,kBAAL,CAAwBL,eAAxB,EAAyCG,SAAzC,C;;;;AAGRD,0BAAU,KAAKI,sBAAL,CAA4BN,eAA5B,CAAV;kDACOE,O;;;;;;;;;;;;;;;;;AAGT;;;;;;;6GAGkBO,W;;;;;;;AACVC,4B,GAAeC,iBAAOC,KAAP,CAAaC,QAAb,CAAsBJ,WAAtB,C;;uBACG,KAAKpB,MAAL,CAAYyB,WAAZ,CAAwBJ,YAAxB,C;;;AAAlBK,yB;wCAEgCJ,iBAAOC,KAAP,CAAaI,cAAb,CACpCD,SADoC,C,EAA3BE,I,yBAAHC,C,EAAYC,I,yBAAHC,C,EAAYC,I,yBAAHC,C;kDAGnB;AACLL,4BADK;AAELE,4BAFK;AAGLE;AAHK,iB;;;;;;;;;;;;;;;;;AAOT;;;;AAIA;;;;8BACUE,M,UAAgE;AAAA,UAAvCN,IAAuC,UAAvCA,IAAuC;AAAA,UAAjCE,IAAiC,UAAjCA,IAAiC;AAAA,UAA3BE,IAA2B,UAA3BA,IAA2B;;AACxE;AACA;AACA,UAAMG,gBAAgBH,OAAO,EAA7B;AACA,aAAOV,iBAAOc,UAAP,CAAkBC,OAAlB,CAA0BH,MAA1B,EAAkCN,IAAlC,EAAwCE,IAAxC,EAA8CK,aAA9C,CAAP;AACD;;;;;kBA9GkBtC,a","file":"EthersAdapter.js","sourcesContent":["/* @flow */\n\nimport ethers from 'ethers';\nimport { raceAgainstTimeout } from '@colony/colony-js-utils';\nimport type {\n  IContract,\n  IAdapter,\n  IProvider,\n  IWallet,\n  Signature,\n  Transaction,\n} from '@colony/colony-js-adapter';\nimport type { Query } from '@colony/colony-js-contract-loader';\n\nimport ContractLoader from '@colony/colony-js-contract-loader';\n\nimport type { ConstructorArgs } from './flowtypes';\nimport EthersContract from './EthersContract';\n\nimport { DEFAULT_TRANSACTION_WAIT_TIMEOUT } from './defaults';\n\nexport default class EthersAdapter implements IAdapter {\n  loader: ContractLoader;\n\n  provider: IProvider;\n\n  wallet: IWallet;\n\n  constructor({ loader, provider, wallet }: ConstructorArgs) {\n    this.loader = loader;\n    this.provider = provider;\n    this.wallet = wallet;\n  }\n\n  async getContract(query: Query): Promise<IContract> {\n    const { address, abi } =\n      (await this.loader.load(query, {\n        abi: true,\n        address: true,\n        bytecode: false,\n      })) || {};\n\n    if (typeof address !== 'string')\n      throw new Error('Unable to parse contract address');\n\n    return new EthersContract(address, abi, this.wallet);\n  }\n\n  async getContractDeployTransaction(\n    query: Query,\n    contractParams: Array<any>,\n  ): Promise<Transaction> {\n    const { abi, bytecode } = await this.loader.load(query, {\n      abi: true,\n      address: false,\n      bytecode: true,\n    });\n    return ethers.Contract.getDeployTransaction(\n      bytecode,\n      abi,\n      ...contractParams,\n    );\n  }\n\n  async _getTransactionReceipt(transactionHash: string) {\n    const receipt = await this.provider.getTransactionReceipt(transactionHash);\n    if (receipt == null)\n      throw new Error(\n        `Transaction receipt not found (transaction: ${transactionHash})`,\n      );\n    return receipt;\n  }\n\n  async waitForTransaction(\n    transactionHash: string,\n    timeoutMs: number = DEFAULT_TRANSACTION_WAIT_TIMEOUT,\n  ) {\n    return raceAgainstTimeout(\n      this.provider.waitForTransaction(transactionHash),\n      timeoutMs,\n    );\n  }\n\n  async getTransactionReceipt(transactionHash: string, timeoutMs?: number) {\n    let receipt;\n    try {\n      // Attempt to get the receipt immediately; the transaction may have\n      // already been mined, or we're running on TestRPC with no mining time.\n      receipt = await this._getTransactionReceipt(transactionHash);\n    } catch (error) {\n      // Ignore the error if the receipt wasn't found\n      if (!error.toString().includes('Transaction receipt not found'))\n        throw error;\n    }\n\n    // If we didn't get the receipt, wait for the transaction and try again.\n    if (!receipt) {\n      await this.waitForTransaction(transactionHash, timeoutMs);\n    }\n\n    receipt = this._getTransactionReceipt(transactionHash);\n    return receipt;\n  }\n\n  /**\n   * Sign a message hash (as binary) and return a split signature.\n   */\n  async signMessage(messageHash: string) {\n    const messageBytes = ethers.utils.arrayify(messageHash);\n    const signature = await this.wallet.signMessage(messageBytes);\n\n    const { r: sigR, s: sigS, v: sigV } = ethers.utils.splitSignature(\n      signature,\n    );\n    return {\n      sigR,\n      sigS,\n      sigV,\n    };\n  }\n\n  /**\n   * Given a message digest and a signature, recover the address used to\n   * sign the message.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  ecRecover(digest: Array<number>, { sigR, sigS, sigV }: Signature): string {\n    // This method doesn't need to be static, but flow Interfaces don't\n    // support static methods.\n    const recoveryParam = sigV - 27;\n    return ethers.SigningKey.recover(digest, sigR, sigS, recoveryParam);\n  }\n}\n"]}